[{"title":"SpringBoot集成Xxl-job做定时任务","date":"2022-10-26T10:00:05.000Z","url":"/2022/10/26/%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90XXL-JOB%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","tags":[["SpringBoot","/tags/SpringBoot/"],["定时任务","/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"]],"categories":[["SpringBoot集成框架","/categories/SpringBoot%E9%9B%86%E6%88%90%E6%A1%86%E6%9E%B6/"]],"content":"1、XXL-JOB实现定时任务条件项目地址github.com&#x2F;xuxueli&#x2F;xxl-job下载下来  要实现定时任务需要两个组件： 1：任务调度器xxl-job-admin 2: 任务执行器 2、前置条件运行任务调度器xxl-job-admin1、导入sql文件 mysql生成表：在db目录下下载sql文件。直接导入到数据库 postgeSQL生成表： 直接把mysql的表复制到pgsql上，但是主键需要加上序列，有些属性要给上默认值。 当懒狗直接运行我改好的，直接下载运行sql文件 2、修改xxl-job-admin配置文件主要运行端口，邮箱，数据库配置等等，右手就行 3、运行xxl-job-admin搞完了直接运行，如果PGSQL运行时xml文件报错请用我的。  运行直接网页localhost:8080&#x2F;xxl-job-admin访问输入账号密码： admin 123456 任务管理：你所有的定时任务。 调度日志：定时任务运行情况 执行器管理：相当于你要执行这个任务的服务，后面服务要进行配置，与Appname一样。 用户管理：懂得都懂 4、因为xxl-job有权限用http访问不到所以新建几个接口开放权限@PermissionLimit(limit &#x3D; false)跳过权限验证。增删查改的逻辑按需求修改。 任务详情JobInfoController加接口 工作组JobGroup加接口 3、编写自己的任务执行器1、自己的项目导入xxl核心依赖 2、编写配置类 配置文件，需要的自己改 3、添加调用xxl-job-Admin的工具类对任务进行增删改查和页面上请求一样 任务详情类 4、使用写一个执行器clockInJobHandler 修改XxlJobInfo的数据实现定时任务,添加任务后，在admin网页上可以看到新建的任务信息。 "},{"title":"linux部署环境","date":"2022-09-29T06:13:27.000Z","url":"/2022/09/29/linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/","tags":[["环境部署","/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"]],"categories":[["undefined",""]],"content":"编程环境和软件工具安装手册.pdf"},{"title":"JVM入门","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/JVM%E5%85%A5%E9%97%A8/","tags":[["JVM","/tags/JVM/"]],"categories":[["Java基础","/categories/Java%E5%9F%BA%E7%A1%80/"]],"content":"JVM入门1、什么是垃圾 引用计数算法：为对象添加一个引用计数器，每当对象在一个地方被引用，则该计数器加1；每当对象引用失效时，计数器减1。但计数器为0的时候，就表白该对象没有被引用。 可达性分析算法：通过一系列被称之为“GC Roots”的根节点开始，沿着引用链进行搜索，凡是在引用链上的对象都不会被回收。 什么是GC roots Java虚拟机栈中被引用的对象，各个线程调用的参数、局部变量、临时变量等。 方法区中类静态属性引用的对象，比如引用类型的静态变量 方法区中常量引用的对象 本地方法栈中所引用的对象 Java虚拟机内部的引用，基本数据类型对应的Class对象。一些常驻的异常对象 被同步锁（synchronized）持有的对象 2、垃圾回收算法标记–清除算法 字面含义，对无效的对象进行标记，然后清除。 优点：哪里不对标哪里后面直接清除就完事，简单快捷。 缺点：进行垃圾回收后，堆空间会有大量的碎片，出现了不规整的情况，在给大对象分配内存的时候由于无法找到足够连续的内存空间，就不得补再一次触发垃圾收集，另外，如果Java堆中存在大量的垃圾对象，那么垃圾回收就必然进行大量的标记和清除动作，这个会造成回收效率的降低。 复制算法 复制算法就是把Java堆分成两块，每次垃圾回收时只使用其中一块，然后把存活的对象全部移动到另一块区域。 优点。解决了清除算法导致的碎片化空间， 缺点，每次只使用堆空间的一半，造成了java堆空间使用率的下降。 标记整理算法​ 标记–整理算法算是一种折中的垃圾收集算法，在对象标记的过程，和前面两个执行的是一样步骤。但是，进行标记之后，存活的对象会移动到堆的一端，然后直接清理存活对象以外的区域就可以了。这样，既避免了内存碎片，也不存在堆空间浪费的说法了。但是，每次进行垃圾回收的时候，都要暂停所有的用户线程，特别是对老年代的对象回收，则需要更长的回收时间，这对用户体验是非常不好的。 分代算法​ 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 3、垃圾回收详解 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。 大对象直接进入老年代大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。 大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。 大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。 Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值,可以通过参数 -XX:MaxTenuringThreshold 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种： 部分收集 (Partial GC)： 新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区 "},{"title":"docker部署ELK","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/docker%E9%83%A8%E7%BD%B2ELK%E5%91%BD%E4%BB%A4/","tags":[["docker","/tags/docker/"]],"categories":[["docker","/categories/docker/"]],"content":"Linux命令防火墙命令 systemctl start firewalld systemctl stop firewalld systemctl status firewalld firewall-cmd –zone&#x3D;public –add-port&#x3D;5045&#x2F;tcp –permanent firewall-cmd –reload firewall-cmd –zone&#x3D;public –list-ports 删除挖矿病毒 top查看占有率 ll &#x2F;proc&#x2F;pid(病毒pid) rm -rf &#x2F;boot&#x2F;grub2&#x2F;fonts&#x2F;0wrasx&#x2F;kthreaddk (deleted) crontab -e dd reboot docker部署1、docker部署elasticsearch 2、docker 部署kibana 3、部署logstash日志过滤、转换工具 4、docker安装Filebeat"},{"title":"Hadoop","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/hadoop%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","tags":[["环境部署","/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"]],"categories":[["docker","/categories/docker/"]],"content":"hadoop入门笔记1、hadoop 安装1 、服务器设置1、配置服务器别名和访问 vim &#x2F;etc&#x2F;hosts 2、将三台服务器的ip输入 xxx.xxx.xx hadoop1 xxx.xxx.xx hadoop3 xxx.xxx.xx hadoop2 3、阿里云服务器下本机地址要设置为私有ip（注意） 2 、jdk环境搭建1、解压jdk 2、配置环境变量 3、使环境变量生效 4、查看java版本是否安装成功 ​ 3、hadoop环境搭建1、解压hadoop 2、配置环境变量 3、使环境变量生效 4、查看hadoop版本是否安装成功 遇到的坑：ERROR: Invalid HADOOP_HDFS_HOME 需要在系统下添加 4、务器直接免密码登录1、ssh-keygen -t rsa 再 .ssh目录下生成公私密钥 2、 ssh-copy-id duan 公钥给duan 5、hadoop集群配置权能划分：duan nameNode gao secord nameNode zou RM 6、分发脚本每台机器执行 yum -y install rsync 安装工具 7、启动停止start-dfs.sh&#x2F;stop-dfs.sh start-yarn.sh&#x2F;stop-yarn.sh 8、常用端口号1、HDFS NameNode 内部通讯端口：8020、9000、9820 2、HDFS NameNode web端口 ：9870 3、YARN 查看运行情况得端口8088 4、历史服务器：19888 core-site.xml 2、hadoop hdfs入门操作"},{"title":"SQL优化","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/sql%E4%BC%98%E5%8C%96/","tags":[["sql","/tags/sql/"]],"categories":[["undefined",""]],"content":"十万条数据用全匹配查询SELECT * FROM index_test; 48.459 s 走index索引 0.35s 不走 0.38"},{"title":"spring事务","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/","tags":[["spring事务","/tags/spring%E4%BA%8B%E5%8A%A1/"]],"categories":[["spring事务","/categories/spring%E4%BA%8B%E5%8A%A1/"]],"content":"事务基本知识事务的四大特性分别是：原子性、一致性、隔离性、持久性 1、Spring事务1、spring事务失效三种情况 2、spring事务传播机制"},{"title":"微服务环境搭建","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/","tags":[["微服务","/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"]],"categories":[["undefined",""]],"content":"从0到1搭建微服务项目-核心模块1，微服务对应的springboot版本很重要，可以去官网查看对应版本知道你们懒，所以帮你们截图下来了。 最新版本有很多坑，但是我们 "},{"title":"多线程","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":[["Java基础","/tags/Java%E5%9F%BA%E7%A1%80/"]],"categories":[["Java基础","/categories/Java%E5%9F%BA%E7%A1%80/"]],"content":"深入理解多线程1、线程基础概念​ 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。Java有6种状态（初始化，运行，阻塞，等待，等待超时，终止） 1、新建状态（New）：新创建了一个线程对象。 2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。6、等待超时（TIMED_WAITING）：具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定时等待状态： Thread.sleepObject.wait超时Thread.join超时LockSupport.parkNanosLockSupport.parkUntil 2、Thread类解析1、控制线程执行优先级 通过getPriority() setPriority()来获取喝设置线程优先级， 1、java线程是通过映射到系统的原生线程上来实现的，所以线程的调度最终还是取决于操作系统，操作系统的优先级与java的优先级并不一一对应，如果操作系统的优先级级数大于java的优先级级数（10级）还好，但是如果小于得的话就不行了，这样会导致不同优先级的线程的优先级是一样的。2、优先级可能会被系统自动改变，比如windows系统中就存在一个优先级推进器，大致功能就是如果一个线程执行的次数过多的话，可能会越过优先级为他分配执行时间。 如果严格按照优先级，那么可能会出现某个线程一直不执行的情况"},{"title":"设计模式","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","tags":[["面对对象编程","/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"]],"categories":[["Java基础","/categories/Java%E5%9F%BA%E7%A1%80/"]],"content":"设计原理 SRP单一职责原则。 OCP开闭原则。 LSP里氏替换原则。 ISP接口隔离原则。 DIP依赖倒置原则。 DRY原则，KISS原则、YAGNI原则、LOD法则 。 设计模式1、创造型常用：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 不常用：原型模式 2、结构模式常用：代理模式、桥接模式、装饰者模式、适配器模式。 不常用: 门面模式、组合模式、享元模式。 3、行为模式常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。"},{"title":"springboot集成dubbo以nacos为注册中心","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/springboot%E9%9B%86%E6%88%90dubbo%E4%BB%A5nacos%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","tags":[["Dubbo","/tags/Dubbo/"],["Nacos","/tags/Nacos/"]],"categories":[["RPC","/categories/RPC/"]],"content":"1、依赖导入注意：3.0以后的dubbo版本。nacos的客户端版本要2.0以上，不然会报错。 2、配置文件没啥好说的。nacos作为配置注册中心，dubbo，设置nacos为注册中心，设置接入协议。 3、服务提供者使用在启动类设置Dubbo启动扫描的。 4、消费者使用直接引入和生产者一样的依赖还需要引入消费者模块。 5、结果"},{"title":"后端存储实战","date":"2022-09-14T10:00:05.000Z","url":"/2022/09/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/","tags":[["后端存储实战","/tags/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"]],"categories":[["undefined",""]],"content":"1、后端存储实战1、如何避免重复下单？接下来我们来看一个场景。一个订单系统，提供创建订单的 HTTP 接口，用户在浏览器页面上点击“提交订单”按钮的时候，浏览器就会给订单系统发一个创建订单的请求，订单系统的后端服务，在收到请求之后，往数据库的订单表插入一条订单数据，创建订单成功。假如说，用户点击“创建订单”的按钮时手一抖，点了两下，浏览器发了两个 HTTP 请求，结果是什么？创建了两条一模一样的订单。这样肯定不行，需要做防重 解决方法：生成订单id 2、如何解决 ABA 问题？正常情况下，订单中的快递单号会先更新成 666，再更新成 888，这是没问题的。那不正常情况呢？666 请求到了，单号更新成 666，然后 888 请求到了，单号又更新成 888，但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了，这数据显然就错了。这就是非常有名的 ABA 问题。 解决方法：给订单主表生成一个版本号.执行更新请求比较版本号类似于乐观锁。"},{"title":"centos安装maven","date":"2022-08-04T07:22:00.000Z","url":"/2022/08/04/centos%E5%AE%89%E8%A3%85maven/","tags":[["centos","/tags/centos/"],["maven","/tags/maven/"]],"categories":[["centos","/categories/centos/"]],"content":"进入目录 下载maven 解压 重命名 配置 添加配置 重新加载配置 验证是否安装成功 进入maven 创建repository目录 修改配置文件 配置依赖存储路径 配置阿里云镜像加速"},{"title":"docker-compose命令","date":"2022-08-04T06:53:08.000Z","url":"/2022/08/04/docker-compose%E5%91%BD%E4%BB%A4/","tags":[["docker-compose","/tags/docker-compose/"],["命令","/tags/%E5%91%BD%E4%BB%A4/"]],"categories":[["命令","/categories/%E5%91%BD%E4%BB%A4/"]],"content":"停掉服务，删除容器，不删除镜像 重启&#x2F;开始&#x2F;停止服务 运行某个服务 查看服务中使用的镜像 重新构建（强制删除之前的镜像重新打）并启动"},{"title":"hexo安装与搭建","date":"2022-07-01T09:01:39.000Z","url":"/2022/07/01/hexo%E5%AE%89%E8%A3%85%E4%B8%8E%E6%90%AD%E5%BB%BA/","tags":[["hexo","/tags/hexo/"]],"categories":[["undefined",""]],"content":"安装hexo 建站 启动"},{"title":"docker常用命令","date":"2022-07-01T07:53:36.000Z","url":"/2022/07/01/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["docker","/tags/docker/"],["命令","/tags/%E5%91%BD%E4%BB%A4/"]],"categories":[["docker","/categories/docker/"]],"content":"docker启动docker服务 关闭docker服务 重启docker服务 搜索镜像 下载镜像 列出镜像 删除镜像 指定名称删除镜像 指定名称删除镜像（强制） 删除所有没有引用的镜像 强制删除所有镜像 列出容器 列出运行中的容器 列出所有容器 停止容器 强制停止容器 启动容器 进入容器 先查询出容器的pid 根据容器的pid进入容器 查看容器的IP地址 将容器启动方式改为always 同步宿主机时间到容器 指定容器时区 查看容器资源占用状况 查看指定容器资源占用状况，比如cpu、内存、网络、io状态 查看所有容器资源占用情况 查看容器磁盘使用情况 执行容器内部命令 指定账号进入容器内部 查看所有网络 创建外部网络 指定容器网络 Docker容器清理 查看Docker占用的磁盘空间情况 删除所有关闭的容器 删除所有dangling镜像(没有Tag的镜像) 删除所有dangling数据卷(即无用的 volume) "},{"title":"git配置ssh","date":"2022-07-01T07:40:04.000Z","url":"/2022/07/01/git%E9%85%8D%E7%BD%AEssh/","tags":[["Git","/tags/Git/"],["SSH","/tags/SSH/"]],"categories":[["undefined",""]],"content":"配置用户名 配置邮箱 生成 ssh key 生成路径"},{"title":"docker安装RabbitMQ","date":"2022-07-01T03:49:55.000Z","url":"/2022/07/01/docker%E5%AE%89%E8%A3%85RabbitMQ/","tags":[["docker","/tags/docker/"],["RabbitMQ","/tags/RabbitMQ/"]],"categories":[["docker","/categories/docker/"]],"content":""},{"title":"docker安装redis","date":"2022-07-01T03:49:20.000Z","url":"/2022/07/01/docker%E5%AE%89%E8%A3%85redis/","tags":[["docker","/tags/docker/"],["redis","/tags/redis/"]],"categories":[["docker","/categories/docker/"]],"content":""},{"title":"docker安装nacos","date":"2022-07-01T03:49:11.000Z","url":"/2022/07/01/docker%E5%AE%89%E8%A3%85nacos/","tags":[["docker","/tags/docker/"],["nacos","/tags/nacos/"]],"categories":[["docker","/categories/docker/"]],"content":"拉取docker镜像 创建临时容器（用来拷贝配置、日志使用） 创建文件夹 配置文件复制 删除临时容器 创建并启动容器"},{"title":"docker安装MySQL","date":"2022-07-01T03:49:00.000Z","url":"/2022/07/01/docker%E5%AE%89%E8%A3%85MySQL/","tags":[["docker","/tags/docker/"],["MySQL","/tags/MySQL/"]],"categories":[["docker","/categories/docker/"]],"content":"拉取5.7的镜像 启动容器 进入容器 登录 开启远程连接 刷新"},{"title":"centos常用命令","date":"2022-07-01T03:39:11.000Z","url":"/2022/07/01/centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":[["centos","/tags/centos/"],["命令","/tags/%E5%91%BD%E4%BB%A4/"]],"categories":[["命令","/categories/%E5%91%BD%E4%BB%A4/"]],"content":"开启防火墙 关闭防火墙 查看防火墙状态 开放某个端口 重新加载配置 查看已经开放的端口 查找（在**中填写你要的查找的路径）"},{"title":"centos安装nginx","date":"2022-07-01T03:23:10.000Z","url":"/2022/07/01/centos%E5%AE%89%E8%A3%85nginx/","tags":[["centos","/tags/centos/"],["nginx","/tags/nginx/"]],"categories":[["centos装机必备","/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"]],"content":"安装依赖 下载稳定版本 解压 进入目录 配置编译 安装 被安装的目录"},{"title":"centos安装docker-compose","date":"2022-07-01T02:57:31.000Z","url":"/2022/07/01/centos%E5%AE%89%E8%A3%85docker-compose/","tags":[["centos","/tags/centos/"],["docker-compose","/tags/docker-compose/"]],"categories":[["centos装机必备","/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"]],"content":" "},{"title":"centos安装docker","date":"2022-07-01T02:57:10.000Z","url":"/2022/07/01/centos%E5%AE%89%E8%A3%85docker/","tags":[["centos","/tags/centos/"],["docker","/tags/docker/"]],"categories":[["centos装机必备","/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"]],"content":"卸载旧版本 安装配置相关依赖 安装docker引擎 启动docker 设置开机自启动 验证是否正确安装 配置阿里云镜像加速 "}]