{"meta":{"title":"Mink的博客","subtitle":"","description":"用于记录一些有意思的事","author":"Mink","url":"https://mink.yoonada.cn","root":"/"},"pages":[],"posts":[{"title":"SpringBoot集成Xxl-job做定时任务","slug":"项目集成XXL-JOB实现定时任务","date":"2022-10-26T10:12:24.276Z","updated":"2022-10-28T06:15:21.366Z","comments":true,"path":"2022/10/26/项目集成XXL-JOB实现定时任务/","link":"","permalink":"https://mink.yoonada.cn/2022/10/26/%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90XXL-JOB%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"1、XXL-JOB实现定时任务条件项目地址github.com&#x2F;xuxueli&#x2F;xxl-job下载下来 http://42.194.208.171:9000/images/XXLjob.png 要实现定时任务需要两个组件： 1：任务调度器xxl-job-admin 2: 任务执行器 2、前置条件运行任务调度器xxl-job-admin1、导入sql文件https://github.com/xuxueli/xxl-job/tree/master/doc/db mysql生成表：在db目录下下载sql文件。直接导入到数据库 postgeSQL生成表：http://42.194.208.171:9000/images/xxl_job_Postge.sql 直接把mysql的表复制到pgsql上，但是主键需要加上序列，有些属性要给上默认值。 当懒狗直接运行我改好的，直接下载运行sql文件 2、修改xxl-job-admin配置文件主要运行端口，邮箱，数据库配置等等，右手就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970### webserver.port=8080server.servlet.context-path=/xxl-job-admin### actuatormanagement.server.servlet.context-path=/actuatormanagement.health.mail.enabled=false### resourcesspring.mvc.servlet.load-on-startup=0spring.mvc.static-path-pattern=/static/**spring.resources.static-locations=classpath:/static/### freemarkerspring.freemarker.templateLoaderPath=classpath:/templates/spring.freemarker.suffix=.ftlspring.freemarker.charset=UTF-8spring.freemarker.request-context-attribute=requestspring.freemarker.settings.number_format=0.############# mybatismybatis.mapper-locations=classpath:/mybatis-mapper/*Mapper.xml#mybatis.type-aliases-package=com.xxl.job.admin.core.model### xxl-job, datasourcespring.datasource.url=jdbc:postgresql://127.0.0.1:5432/xxl-job?&amp;schema=device&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;stringtype=unspecified&amp;serverTimezone=GMT%2B8spring.datasource.username=postgresspring.datasource.password=postgres123spring.datasource.driver-class-name=org.postgresql.Driver### datasource-poolspring.datasource.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.hikari.minimum-idle=10spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.auto-commit=truespring.datasource.hikari.idle-timeout=30000spring.datasource.hikari.pool-name=HikariCPspring.datasource.hikari.max-lifetime=900000spring.datasource.hikari.connection-timeout=10000spring.datasource.hikari.connection-test-query=SELECT 1spring.datasource.hikari.validation-timeout=1000### xxl-job, emailspring.mail.host=smtp.qq.comspring.mail.port=25spring.mail.username=xxx@qq.comspring.mail.from=xxx@qq.comspring.mail.password=xxxspring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truespring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory### xxl-job, access tokenxxl.job.accessToken=default_token### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)xxl.job.i18n=zh_CN## xxl-job, triggerpool max sizexxl.job.triggerpool.fast.max=200xxl.job.triggerpool.slow.max=100### xxl-job, log retention daysxxl.job.logretentiondays=30xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job executor log-retention-daysxxl.job.executor.logretentiondays=30 3、运行xxl-job-admin搞完了直接运行，如果PGSQL运行时xml文件报错请用我的。 http://42.194.208.171:9000/images/mybatis-mapper/mybatis-mapper.zip 运行直接网页localhost:8080&#x2F;xxl-job-admin访问输入账号密码： admin 123456 任务管理：你所有的定时任务。 调度日志：定时任务运行情况 执行器管理：相当于你要执行这个任务的服务，后面服务要进行配置，与Appname一样。 用户管理：懂得都懂 4、因为xxl-job有权限用http访问不到所以新建几个接口开放权限@PermissionLimit(limit &#x3D; false)跳过权限验证。增删查改的逻辑按需求修改。 任务详情JobInfoController加接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 新建方法 *//*------------------自定义方法---------------------- */@RequestMapping(&quot;/addJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; addJobInfo(@RequestBody XxlJobInfo jobInfo) &#123; xxlJobService.add(jobInfo); int id = jobInfo.getId(); return new ReturnT(id);&#125;@RequestMapping(&quot;/updateJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; updateJobCron(@RequestBody XxlJobInfo jobInfo) &#123; return xxlJobService.update(jobInfo);&#125;@RequestMapping(&quot;/removeJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; removeJob(@RequestBody XxlJobInfo jobInfo) &#123; return xxlJobService.remove(jobInfo.getId());&#125;@RequestMapping(&quot;/pauseJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; pauseJob(@RequestBody XxlJobInfo jobInfo) &#123; return xxlJobService.stop(jobInfo.getId());&#125;@RequestMapping(&quot;/startJob&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; startJob(@RequestBody XxlJobInfo jobInfo) &#123; return xxlJobService.start(jobInfo.getId());&#125;@RequestMapping(&quot;/addAndStart&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; addAndStart(@RequestBody XxlJobInfo jobInfo) &#123; ReturnT&lt;String&gt; result = xxlJobService.add(jobInfo); int id = Integer.valueOf(result.getContent()); xxlJobService.start(id); return result;&#125; 工作组JobGroup加接口 1234567@RequestMapping(&quot;/getGroupId&quot;)@ResponseBody@PermissionLimit(limit = false)public ReturnT&lt;String&gt; getGroupId(@RequestBody XxlJobGroup jobGroup) &#123; XxlJobGroup group = xxlJobGroupDao.findByName(jobGroup.getAppname()); return new ReturnT&lt;String&gt;(String.valueOf(group.getId()));&#125; 3、编写自己的任务执行器1、自己的项目导入xxl核心依赖12345&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt;&lt;/dependency&gt; 2、编写配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.suntang.ssc.ipms.integral.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.integral.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125; /** * 针对多网卡、容器内部署等情况，可借助 &quot;spring-cloud-commons&quot; 提供的 &quot;InetUtils&quot; 组件灵活定制注册IP； * * 1、引入依赖： * &lt;dependency&gt; * &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; * &lt;artifactId&gt;spring-cloud-commons&lt;/artifactId&gt; * &lt;version&gt;$&#123;version&#125;&lt;/version&gt; * &lt;/dependency&gt; * * 2、配置文件，或者容器启动变量 * spring.cloud.inetutils.preferred-networks: &#x27;xxx.xxx.xxx.&#x27; * * 3、获取IP * String ip_ = inetUtils.findFirstNonLoopbackHostInfo().getIpAddress(); */ &#125; 1234567891011xxl.job.admin.addresses=http://192.168.8.62:8080/xxl-job-adminxxl.job.executor.appname=xxl-job-executor-ipmsxxl.job.executor.ip=xxl.job.executor.notice.port=9999xxl.job.executor.integral.port=9998xxl.job.executor.address=xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job executor log-retention-daysxxl.job.executor.logretentiondays=30xxl.job.accessToken=default_token 配置文件，需要的自己改 3、添加调用xxl-job-Admin的工具类对任务进行增删改查和页面上请求一样 任务详情类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230package com.suntang.common.job;import java.util.Date;/** * xxl-job info * * @author xuxueli 2016-1-12 18:25:49 */public class XxlJobInfo &#123; private int id; // 主键ID private int jobGroup; // 执行器主键ID private String jobDesc; private Date addTime; private Date updateTime; private String author; // 负责人 private String alarmEmail; // 报警邮件 private String scheduleType; // 调度类型 private String scheduleConf; // 调度配置，值含义取决于调度类型 private String misfireStrategy; // 调度过期策略 private String executorRouteStrategy; // 执行器路由策略 private String executorHandler; // 执行器，任务Handler名称 private String executorParam; // 执行器，任务参数 private String executorBlockStrategy; // 阻塞处理策略 private int executorTimeout; // 任务执行超时时间，单位秒 private int executorFailRetryCount; // 失败重试次数 private String glueType; // GLUE类型 #com.xxl.job.core.glue.GlueTypeEnum private String glueSource; // GLUE源代码 private String glueRemark; // GLUE备注 private Date glueUpdatetime; // GLUE更新时间 private String childJobId; // 子任务ID，多个逗号分隔 private int triggerStatus; // 调度状态：0-停止，1-运行 private long triggerLastTime; // 上次调度时间 private long triggerNextTime; // 下次调度时间 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getJobGroup() &#123; return jobGroup; &#125; public void setJobGroup(int jobGroup) &#123; this.jobGroup = jobGroup; &#125; public String getJobDesc() &#123; return jobDesc; &#125; public void setJobDesc(String jobDesc) &#123; this.jobDesc = jobDesc; &#125; public Date getAddTime() &#123; return addTime; &#125; public void setAddTime(Date addTime) &#123; this.addTime = addTime; &#125; public Date getUpdateTime() &#123; return updateTime; &#125; public void setUpdateTime(Date updateTime) &#123; this.updateTime = updateTime; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getAlarmEmail() &#123; return alarmEmail; &#125; public void setAlarmEmail(String alarmEmail) &#123; this.alarmEmail = alarmEmail; &#125; public String getScheduleType() &#123; return scheduleType; &#125; public void setScheduleType(String scheduleType) &#123; this.scheduleType = scheduleType; &#125; public String getScheduleConf() &#123; return scheduleConf; &#125; public void setScheduleConf(String scheduleConf) &#123; this.scheduleConf = scheduleConf; &#125; public String getMisfireStrategy() &#123; return misfireStrategy; &#125; public void setMisfireStrategy(String misfireStrategy) &#123; this.misfireStrategy = misfireStrategy; &#125; public String getExecutorRouteStrategy() &#123; return executorRouteStrategy; &#125; public void setExecutorRouteStrategy(String executorRouteStrategy) &#123; this.executorRouteStrategy = executorRouteStrategy; &#125; public String getExecutorHandler() &#123; return executorHandler; &#125; public void setExecutorHandler(String executorHandler) &#123; this.executorHandler = executorHandler; &#125; public String getExecutorParam() &#123; return executorParam; &#125; public void setExecutorParam(String executorParam) &#123; this.executorParam = executorParam; &#125; public String getExecutorBlockStrategy() &#123; return executorBlockStrategy; &#125; public void setExecutorBlockStrategy(String executorBlockStrategy) &#123; this.executorBlockStrategy = executorBlockStrategy; &#125; public int getExecutorTimeout() &#123; return executorTimeout; &#125; public void setExecutorTimeout(int executorTimeout) &#123; this.executorTimeout = executorTimeout; &#125; public int getExecutorFailRetryCount() &#123; return executorFailRetryCount; &#125; public void setExecutorFailRetryCount(int executorFailRetryCount) &#123; this.executorFailRetryCount = executorFailRetryCount; &#125; public String getGlueType() &#123; return glueType; &#125; public void setGlueType(String glueType) &#123; this.glueType = glueType; &#125; public String getGlueSource() &#123; return glueSource; &#125; public void setGlueSource(String glueSource) &#123; this.glueSource = glueSource; &#125; public String getGlueRemark() &#123; return glueRemark; &#125; public void setGlueRemark(String glueRemark) &#123; this.glueRemark = glueRemark; &#125; public Date getGlueUpdatetime() &#123; return glueUpdatetime; &#125; public void setGlueUpdatetime(Date glueUpdatetime) &#123; this.glueUpdatetime = glueUpdatetime; &#125; public String getChildJobId() &#123; return childJobId; &#125; public void setChildJobId(String childJobId) &#123; this.childJobId = childJobId; &#125; public int getTriggerStatus() &#123; return triggerStatus; &#125; public void setTriggerStatus(int triggerStatus) &#123; this.triggerStatus = triggerStatus; &#125; public long getTriggerLastTime() &#123; return triggerLastTime; &#125; public void setTriggerLastTime(long triggerLastTime) &#123; this.triggerLastTime = triggerLastTime; &#125; public long getTriggerNextTime() &#123; return triggerNextTime; &#125; public void setTriggerNextTime(long triggerNextTime) &#123; this.triggerNextTime = triggerNextTime; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.suntang.ssc.ipms.integral.util;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.suntang.common.job.XxlJobInfo;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;import java.util.HashMap;import java.util.Map;@Slf4j@Componentpublic class XxlJobUtil &#123; @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; private RestTemplate restTemplate = new RestTemplate(); private static final String ADD_URL = &quot;/jobinfo/addJob&quot;; private static final String UPDATE_URL = &quot;/jobinfo/updateJob&quot;; private static final String REMOVE_URL = &quot;/jobinfo/removeJob&quot;; private static final String PAUSE_URL = &quot;/jobinfo/pauseJob&quot;; private static final String START_URL = &quot;/jobinfo/startJob&quot;; private static final String ADD_START_URL = &quot;/jobinfo/addAndStart&quot;; private static final String GET_GROUP_ID = &quot;/jobgroup/getGroupId&quot;; public String add(XxlJobInfo jobInfo)&#123; // 查询对应groupId: Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;appname&quot;, appname); String json = JSON.toJSONString(param); String result = doPost(adminAddresses + GET_GROUP_ID, json); JSONObject jsonObject = JSON.parseObject(result); String groupId = jsonObject.getString(&quot;content&quot;); jobInfo.setJobGroup(Integer.parseInt(groupId)); String json2 = JSON.toJSONString(jobInfo); return doPost(adminAddresses + ADD_URL, json2); &#125; public String update(int id, String cron)&#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;id&quot;, id); param.put(&quot;jobCron&quot;, cron); String json = JSON.toJSONString(param); return doPost(adminAddresses + UPDATE_URL, json); &#125; public String remove(int id)&#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;id&quot;, id); String json = JSON.toJSONString(param); return doPost(adminAddresses + REMOVE_URL, json); &#125; public String pause(int id)&#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;id&quot;, id); String json = JSON.toJSONString(param); return doPost(adminAddresses + PAUSE_URL, json); &#125; public String start(int id)&#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;id&quot;, id); String json = JSON.toJSONString(param); return doPost(adminAddresses + START_URL, json); &#125; public String addAndStart(XxlJobInfo jobInfo)&#123; Map&lt;String,Object&gt; param = new HashMap&lt;&gt;(); param.put(&quot;appname&quot;, appname); String json = JSON.toJSONString(param); String result = doPost(adminAddresses + GET_GROUP_ID, json); JSONObject jsonObject = JSON.parseObject(result); String groupId = jsonObject.getString(&quot;content&quot;); jobInfo.setJobGroup(Integer.parseInt(groupId)); String json2 = JSON.toJSONString(jobInfo); return doPost(adminAddresses + ADD_START_URL, json2); &#125; public String doPost(String url, String json)&#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;(json ,headers); log.info(entity.toString()); ResponseEntity&lt;String&gt; stringResponseEntity = restTemplate.postForEntity(url, entity, String.class); return stringResponseEntity.getBody().toString(); &#125;&#125; 4、使用写一个执行器clockInJobHandler 123456789101112@Slf4j@Componentpublic class HandleUserTaskJob &#123; @Autowired private UserTaskService userTaskService; @XxlJob(&quot;clockInJobHandler&quot;) public void userTaskJobHandle()&#123; // 定时任务业务逻辑 &#125;&#125; 修改XxlJobInfo的数据实现定时任务,添加任务后，在admin网页上可以看到新建的任务信息。 12345678910111213141516171819202122232425@Testpublic void test()&#123; XxlJobInfo xxlJobInfo = new XxlJobInfo(); xxlJobInfo.setScheduleConf(&quot;0/5 * * * * ?&quot;); xxlJobInfo.setJobGroup(1); xxlJobInfo.setJobDesc(&quot;我来试试&quot;); xxlJobInfo.setAddTime(new Date()); xxlJobInfo.setUpdateTime(new Date()); xxlJobInfo.setAuthor(&quot;JCccc&quot;); xxlJobInfo.setAlarmEmail(&quot;864477182@com&quot;); xxlJobInfo.setScheduleType(&quot;CRON&quot;); xxlJobInfo.setScheduleConf(&quot;0/5 * * * * ?&quot;); xxlJobInfo.setMisfireStrategy(&quot;DO_NOTHING&quot;); xxlJobInfo.setExecutorRouteStrategy(&quot;FIRST&quot;); xxlJobInfo.setExecutorHandler(&quot;clockInJobHandler&quot;); xxlJobInfo.setExecutorParam(&quot;att&quot;); xxlJobInfo.setExecutorBlockStrategy(&quot;SERIAL_EXECUTION&quot;); xxlJobInfo.setExecutorTimeout(0); xxlJobInfo.setExecutorFailRetryCount(1); xxlJobInfo.setGlueType(&quot;BEAN&quot;); xxlJobInfo.setGlueSource(&quot;&quot;); xxlJobInfo.setGlueRemark(&quot;GLUE代码初始化&quot;); xxlJobInfo.setGlueUpdatetime(new Date()); xxlJobUtil.add(xxlJobInfo);&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://mink.yoonada.cn/categories/SpringBoot/"},{"name":"集成框架","slug":"SpringBoot/集成框架","permalink":"https://mink.yoonada.cn/categories/SpringBoot/%E9%9B%86%E6%88%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://mink.yoonada.cn/tags/SpringBoot/"},{"name":"定时任务","slug":"定时任务","permalink":"https://mink.yoonada.cn/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]},{"title":"linux部署环境","slug":"linux部署环境","date":"2022-09-29T06:13:27.000Z","updated":"2022-10-08T08:18:21.936Z","comments":true,"path":"2022/09/29/linux部署环境/","link":"","permalink":"https://mink.yoonada.cn/2022/09/29/linux%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/","excerpt":"","text":"http://114.55.238.234:9000/images/编程环境和软件工具安装手册.pdf","categories":[],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://mink.yoonada.cn/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}]},{"title":"nacos集群出现Grpc问题","slug":"nacos提示Grpc问题","date":"2022-09-29T06:13:27.000Z","updated":"2022-10-28T06:52:29.174Z","comments":true,"path":"2022/09/29/nacos提示Grpc问题/","link":"","permalink":"https://mink.yoonada.cn/2022/09/29/nacos%E6%8F%90%E7%A4%BAGrpc%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、问题产生原因nacos2.x版本以后引入grpc，端口是默认偏移+1000。原来8848偏移1000就是9848。所以我们要开启两个端口。 2、问题解决1、在nginx.conf文件下加入这行。 stream {upstream nacosgrpcc {server 116.62.190.20:9848;server 47.98.236.213:9848;server 114.55.238.234:9848;}server {listen 9858;proxy_connect_timeout 300s;proxy_timeout 300s;proxy_pass nacosgrpcc;}} 2、安装stream使nginx支持这个模块 yum install -y nginx-mod-stream 3、 nginx -s reload","categories":[{"name":"日常问题","slug":"日常问题","permalink":"https://mink.yoonada.cn/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://mink.yoonada.cn/tags/nginx/"}]},{"title":"centos安装maven","slug":"centos安装maven","date":"2022-09-14T10:00:51.498Z","updated":"2022-10-28T03:16:31.801Z","comments":true,"path":"2022/09/14/centos安装maven/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/centos%E5%AE%89%E8%A3%85maven/","excerpt":"","text":"进入目录1cd /usr/local 下载maven1wget https://archive.apache.org/dist/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz 解压1tar -xvf apache-maven-3.6.3-bin.tar.gz 重命名1mv apache-maven-3.6.3 maven 配置1vim /etc/profile 添加配置1export PATH=/usr/local/maven/bin:$PATH 重新加载配置1source /etc/profile 验证是否安装成功1mvn -V 进入maven1cd maven 创建repository目录1mkdir repository 修改配置文件1cd conf/ 1vim settings.xml 配置依赖存储路径1&lt;localRepository&gt;/usr/local/maven/repository&lt;/localRepository&gt; 配置阿里云镜像加速123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;nexus-aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt;","categories":[{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"环境","slug":"centos装机必备/环境","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"maven","slug":"maven","permalink":"https://mink.yoonada.cn/tags/maven/"}]},{"title":"centos安装docker","slug":"centos安装docker","date":"2022-09-14T10:00:51.469Z","updated":"2022-10-28T03:13:20.813Z","comments":true,"path":"2022/09/14/centos安装docker/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/centos%E5%AE%89%E8%A3%85docker/","excerpt":"","text":"卸载旧版本12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装配置相关依赖1sudo yum install -y yum-utils 123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker引擎1sudo yum install docker-ce docker-ce-cli containerd.io 启动docker1sudo systemctl start docker 设置开机自启动1sudo systemctl enable docker 验证是否正确安装1sudo docker run hello-world 配置阿里云镜像加速1sudo mkdir -p /etc/docker 12345sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://9w9zqgnf.mirror.aliyuncs.com&quot;]&#125;EOF 1sudo systemctl daemon-reload 1sudo systemctl restart docker","categories":[{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"docker","slug":"centos装机必备/docker","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"}]},{"title":"JVM入门","slug":"JVM入门","date":"2022-09-14T10:00:05.000Z","updated":"2023-01-29T01:40:58.392Z","comments":true,"path":"2022/09/14/JVM入门/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/JVM%E5%85%A5%E9%97%A8/","excerpt":"","text":"JVM入门1、什么是垃圾 引用计数算法：为对象添加一个引用计数器，每当对象在一个地方被引用，则该计数器加1；每当对象引用失效时，计数器减1。但计数器为0的时候，就表白该对象没有被引用。 可达性分析算法：通过一系列被称之为“GC Roots”的根节点开始，沿着引用链进行搜索，凡是在引用链上的对象都不会被回收。 什么是GC roots Java虚拟机栈中被引用的对象，各个线程调用的参数、局部变量、临时变量等。 方法区中类静态属性引用的对象，比如引用类型的静态变量 方法区中常量引用的对象 本地方法栈中所引用的对象 Java虚拟机内部的引用，基本数据类型对应的Class对象。一些常驻的异常对象 被同步锁（synchronized）持有的对象 2、垃圾回收算法标记–清除算法 字面含义，对无效的对象进行标记，然后清除。 优点：哪里不对标哪里后面直接清除就完事，简单快捷。 缺点：进行垃圾回收后，堆空间会有大量的碎片，出现了不规整的情况，在给大对象分配内存的时候由于无法找到足够连续的内存空间，就不得补再一次触发垃圾收集，另外，如果Java堆中存在大量的垃圾对象，那么垃圾回收就必然进行大量的标记和清除动作，这个会造成回收效率的降低。 复制算法 复制算法就是把Java堆分成两块，每次垃圾回收时只使用其中一块，然后把存活的对象全部移动到另一块区域。 优点。解决了清除算法导致的碎片化空间， 缺点，每次只使用堆空间的一半，造成了java堆空间使用率的下降。 标记整理算法​ 标记–整理算法算是一种折中的垃圾收集算法，在对象标记的过程，和前面两个执行的是一样步骤。但是，进行标记之后，存活的对象会移动到堆的一端，然后直接清理存活对象以外的区域就可以了。这样，既避免了内存碎片，也不存在堆空间浪费的说法了。但是，每次进行垃圾回收的时候，都要暂停所有的用户线程，特别是对老年代的对象回收，则需要更长的回收时间，这对用户体验是非常不好的。 分代算法​ 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。 3、垃圾回收详解 先按照图中的操作打印出GC详情数据。JDK1.8 分为年轻代，老年代。元空间。 当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。 大对象直接进入老年代大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。 大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率 长期存活的对象将进入老年代既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。 大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。 Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 -XX:TargetSurvivorRatio=percent 来设置，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值,可以通过参数 -XX:MaxTenuringThreshold 针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种： 部分收集 (Partial GC)： 新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://mink.yoonada.cn/tags/JVM/"}]},{"title":"docker部署ELK","slug":"docker部署ELK命令","date":"2022-09-14T10:00:05.000Z","updated":"2022-10-28T03:17:47.376Z","comments":true,"path":"2022/09/14/docker部署ELK命令/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/docker%E9%83%A8%E7%BD%B2ELK%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux命令防火墙命令 systemctl start firewalld systemctl stop firewalld systemctl status firewalld firewall-cmd –zone&#x3D;public –add-port&#x3D;5045&#x2F;tcp –permanent firewall-cmd –reload firewall-cmd –zone&#x3D;public –list-ports 删除挖矿病毒 top查看占有率 ll &#x2F;proc&#x2F;pid(病毒pid) rm -rf &#x2F;boot&#x2F;grub2&#x2F;fonts&#x2F;0wrasx&#x2F;kthreaddk (deleted) crontab -e dd reboot docker部署1、docker部署elasticsearch123456789101112docker pull elasticsearch:7.14.0mkdir -p /gdgx/ymk/elk/es/&#123;config,data,logs&#125;chown -R 1000:1000 /gdgx/ymk/elkcd /gdgx/ymk/elk/es/configtouch elasticsearch.yml-----------------------配置内容----------------------------------cluster.name: &quot;my-es&quot;network.host: 0.0.0.0http.port: 9200-----------------------启动命令--------------------------------docker run -it -d -p 4200:9200 -p 4000:9300 --name kes -e ES_JAVA_OPTS=&quot;-Xms1g -Xmx1g&quot; -e &quot;discovery.type=single-node&quot; --restart=always -v /gdgx/ymk/elk/es/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /gdgx/ymk/elk/es/data:/usr/share/elasticsearch/data -v /gdgx/ymk/elk/es/logs:/usr/share/elasticsearch/logs elasticsearch:7.14.0 2、docker 部署kibana12345678910111213docker pull kibana:7.14.0docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; esmkdir -p /gdgx/ymk/elk/kibana/vim /gdgx/ymk/elk/kibana/kibana.yml-------------配置信息---------------server.name: kibanaserver.host: &quot;0&quot;elasticsearch.hosts: [&quot;http://172.17.0.5:9200&quot;]xpack.monitoring.ui.container.elasticsearch.enabled: truei18n.locale: &quot;zh-CN&quot;--------------启动命令--------------------docker run -d --restart=always --log-driver json-file --log-opt max-size=100m --log-opt max-file=2 --name kibana -p 4001:5601 -v /gdgx/ymk/elk/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml kibana:7.14.0 3、部署logstash日志过滤、转换工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354docker pull logstash:7.14.0docker run -d --name=logstash logstash:7.14.0docker logs -f logstashdocker cp logstash:/usr/share/logstash /docker/elk/mkdir /docker/elk/logstashchmod 777 -R /docker/elk/logstash----------yml配置信息——--------------------------vi /docker/elk/logstash/config/logstash.ymlhttp.host: &quot;0.0.0.0&quot;xpack.monitoring.elasticsearch.hosts: [&quot;http://114.55.238.234:9200&quot;]path.config: /usr/share/logstash/config/*.confpath.logs: /usr/share/logstash/logs-----------配置信息——------------vi /data/elk/logstash/config/logstash.conf# Sample Logstash configuration for creating a simple# Beats -&gt; Logstash -&gt; Elasticsearch pipeline.input &#123; tcp &#123; port =&gt; 5045 type =&gt; syslog &#125; beats &#123; port =&gt; &quot;5044&quot; type =&gt; file &#125;&#125;output &#123; stdout &#123; codec =&gt; rubydebug &#125; if[type] == &quot;file&quot; &#123; elasticsearch&#123; hosts =&gt; [&quot;http://114.55.238.234:9200&quot;] index =&gt; &quot;filelogs-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125; elasticsearch&#123; hosts =&gt; [&quot;http://114.55.238.234:9200&quot;] index =&gt; &quot;mylogs-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125;docker rm -f logstash-----------启动命令----------docker run -d \\ --name=logstash \\ --restart=always \\ -p 5044:5044 \\ -v /docker/elk/logstash:/usr/share/logstash \\ -v /var/log/messages:/var/log/messages \\ logstash:7.14.0 4、docker安装Filebeat123456789101112131415161718192021222324docker pull docker.elastic.co/beats/filebeat:7.14.0---------修改yml配置文件----------vim /docker/elk/filebeat/filebeat.yml---------配置信息-----------------filebeat.inputs:- type: log enabled: true paths: - /home/log/*.log multiline.pattern: &#x27;^\\[&#x27; multiline.negate: true multiline.match: afteroutput.logstash: hosts: [&quot;114.55.238.234:5044&quot;]----------启动命令---------------docker run --name filebeat -d \\ -v /home/logs:/home/logs:ro \\ -v /docker/elk/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml \\ docker.elastic.co/beats/filebeat:7.14.0","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"}]},{"title":"Hadoop","slug":"hadoop入门笔记","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-16T03:17:33.692Z","comments":true,"path":"2022/09/14/hadoop入门笔记/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/hadoop%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","excerpt":"","text":"hadoop入门笔记1、hadoop 安装1 、服务器设置1、配置服务器别名和访问 vim &#x2F;etc&#x2F;hosts 2、将三台服务器的ip输入 xxx.xxx.xx hadoop1 xxx.xxx.xx hadoop3 xxx.xxx.xx hadoop2 3、阿里云服务器下本机地址要设置为私有ip（注意） 2 、jdk环境搭建1、解压jdk 2、配置环境变量 3、使环境变量生效 4、查看java版本是否安装成功 12345678tar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./vim /etc/profileJAVA_HOME=/usr/local/java/jdk1.8.0_161CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATHsource /etc/profilejava -version ​ 3、hadoop环境搭建1、解压hadoop 2、配置环境变量 3、使环境变量生效 4、查看hadoop版本是否安装成功 遇到的坑：ERROR: Invalid HADOOP_HDFS_HOME 需要在系统下添加 12[root@duan local]# vim ~/.bashrc[root@duan local]# source ~/.bash_profile 4、务器直接免密码登录1、ssh-keygen -t rsa 再 .ssh目录下生成公私密钥 2、 ssh-copy-id duan 公钥给duan 5、hadoop集群配置权能划分：duan nameNode gao secord nameNode zou RM 6、分发脚本每台机器执行 yum -y install rsync 安装工具 1234567891011121314151617181920212223242526#!/bin/bash#1.获取输入参数个数，如果没有参数，直接退出pcount=$#if((pcount==0)); thenecho no args;exit;fi#2.获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3.获取上级目录到绝对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4.获取当前用户名称user=`whoami`#5.循环（191,192,193三台机器是我的集群ip）echo ------------------- hadoop$host --------------rsync -rvl $pdir/$fname $user@zou:$pdirrsync -rvl $pdir/$fname $user@duan:$pdirrsync -rvl $pdir/$fname $user@gao:$pdir 7、启动停止start-dfs.sh&#x2F;stop-dfs.sh start-yarn.sh&#x2F;stop-yarn.sh 8、常用端口号1、HDFS NameNode 内部通讯端口：8020、9000、9820 2、HDFS NameNode web端口 ：9870 3、YARN 查看运行情况得端口8088 4、历史服务器：19888 core-site.xml123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;!--设置全局参数，指定HDFS上NN地址为master，端口9000--&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;!--指定HDFS执行时的临时目录，指定NameNode、DataNode、JournalNode等存放数据的公共目录。用户也可以自己单独指定这三类节点的目录。以下的/hdfs/tmp目录与文件都是自己创建的 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop-2.7.3/hdfs/tmp&lt;/value&gt; &lt;description&gt;A base for other tempory directories&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;io.file.buffer.size&lt;/name&gt; &lt;value&gt;131072&lt;/value&gt; &lt;final&gt;4096&lt;/final&gt; &lt;description&gt;流文件的缓冲区为4K&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.checkpoint.period&lt;/name&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.checkpoint.size&lt;/name&gt; &lt;value&gt;67108864&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 2、hadoop hdfs入门操作","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"}],"tags":[{"name":"环境部署","slug":"环境部署","permalink":"https://mink.yoonada.cn/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"}]},{"title":"springboot集成dubbo以nacos为注册中心","slug":"springboot集成dubbo以nacos为注册中心","date":"2022-09-14T10:00:05.000Z","updated":"2022-10-28T03:20:49.684Z","comments":true,"path":"2022/09/14/springboot集成dubbo以nacos为注册中心/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/springboot%E9%9B%86%E6%88%90dubbo%E4%BB%A5nacos%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/","excerpt":"","text":"1、依赖导入注意：3.0以后的dubbo版本。nacos的客户端版本要2.0以上，不然会报错。 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.pua&lt;/groupId&gt; &lt;artifactId&gt;pua-common-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt; &lt;artifactId&gt;nacos-client&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2、配置文件没啥好说的。nacos作为配置注册中心，dubbo，设置nacos为注册中心，设置接入协议。 123456789101112131415161718192021222324252627282930spring: cloud: nacos: host: 47.98.236.213:8848 namespace: pua discovery: server-addr: $&#123;spring.cloud.nacos.host&#125; namespace: $&#123;spring.cloud.nacos.namespace&#125; group: $&#123;spring.profiles.active&#125; config: server-addr: $&#123;spring.cloud.nacos.host&#125; namespace: $&#123;spring.cloud.nacos.namespace&#125; group: $&#123;spring.profiles.active&#125; file-extension: yaml refresh-enabled: true username: nacos password: ENC(F0qwKRQUWxXgXfNDN05yIg==)dubbo: protocol: name: dubbo port: -1 application: name: pua-producer registry: register-mode: interface address: nacos://47.98.236.213:8848 parameters: namespace: $&#123;spring.cloud.nacos.namespace&#125; username: nacos password: ENC(F0qwKRQUWxXgXfNDN05yIg==) 3、服务提供者使用在启动类设置Dubbo启动扫描的。 123456789101112131415161718@EnableEncryptableProperties@SpringBootApplication@EnableDubbo(scanBasePackages = &quot;com.pua.producer.service&quot;)public class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class,args); &#125;&#125;@Service@DubboServicepublic class ProducerServiceImpl implements ProducerService &#123; @Override public String getId() &#123; return &quot;110&quot;; &#125;&#125; 4、消费者使用直接引入和生产者一样的依赖还需要引入消费者模块。 123456&lt;dependency&gt; &lt;groupId&gt;com.pua&lt;/groupId&gt; &lt;artifactId&gt;producer&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 123456789@DubboReference(interfaceClass = ProducerService.class)private ProducerService producerService;@ApiOperation(&quot;测试&quot;)@GetMapping(&quot;/index&quot;)public BaseResult&lt;String&gt; test()&#123; String id = producerService.getId(); return BaseResult.success(id);&#125; 5、结果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://mink.yoonada.cn/categories/SpringBoot/"},{"name":"集成框架","slug":"SpringBoot/集成框架","permalink":"https://mink.yoonada.cn/categories/SpringBoot/%E9%9B%86%E6%88%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"RPC","slug":"RPC","permalink":"https://mink.yoonada.cn/tags/RPC/"}]},{"title":"SQL优化","slug":"sql优化","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-29T06:26:23.927Z","comments":true,"path":"2022/09/14/sql优化/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/sql%E4%BC%98%E5%8C%96/","excerpt":"","text":"十万条数据用全匹配查询SELECT * FROM index_test; 48.459 s 走index索引 0.35s 不走 0.38","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://mink.yoonada.cn/tags/sql/"}]},{"title":"spring事务","slug":"事务相关","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-16T03:17:58.433Z","comments":true,"path":"2022/09/14/事务相关/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/","excerpt":"","text":"事务基本知识事务的四大特性分别是：原子性、一致性、隔离性、持久性 1、Spring事务1、spring事务失效三种情况123451、方法修饰符不为public2、被try cath没抛出异常3、Transactional默认为runtime异常其他的不会回滚 2、spring事务传播机制","categories":[{"name":"spring事务","slug":"spring事务","permalink":"https://mink.yoonada.cn/categories/spring%E4%BA%8B%E5%8A%A1/"}],"tags":[{"name":"spring事务","slug":"spring事务","permalink":"https://mink.yoonada.cn/tags/spring%E4%BA%8B%E5%8A%A1/"}]},{"title":"微服务环境搭建","slug":"从0到1搭建微服务项目-核心模块","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-29T06:26:23.993Z","comments":true,"path":"2022/09/14/从0到1搭建微服务项目-核心模块/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/","excerpt":"","text":"从0到1搭建微服务项目-核心模块1，微服务对应的springboot版本很重要，可以去官网查看对应版本知道你们懒，所以帮你们截图下来了。 最新版本有很多坑，但是我们 123&lt;spring-boot.version&gt;2.5.5&lt;/spring-boot.version&gt;&lt;spring-cloud.version&gt;2020.0.4&lt;/spring-cloud.version&gt;&lt;spring-cloud-alibaba.version&gt;2021.1&lt;/spring-cloud-alibaba.version&gt;","categories":[],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://mink.yoonada.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"后端存储实战","slug":"后端存储实战","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-16T03:01:38.179Z","comments":true,"path":"2022/09/14/后端存储实战/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/","excerpt":"","text":"1、后端存储实战1、如何避免重复下单？接下来我们来看一个场景。一个订单系统，提供创建订单的 HTTP 接口，用户在浏览器页面上点击“提交订单”按钮的时候，浏览器就会给订单系统发一个创建订单的请求，订单系统的后端服务，在收到请求之后，往数据库的订单表插入一条订单数据，创建订单成功。假如说，用户点击“创建订单”的按钮时手一抖，点了两下，浏览器发了两个 HTTP 请求，结果是什么？创建了两条一模一样的订单。这样肯定不行，需要做防重 解决方法：生成订单id 2、如何解决 ABA 问题？正常情况下，订单中的快递单号会先更新成 666，再更新成 888，这是没问题的。那不正常情况呢？666 请求到了，单号更新成 666，然后 888 请求到了，单号又更新成 888，但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了，这数据显然就错了。这就是非常有名的 ABA 问题。 解决方法：给订单主表生成一个版本号.执行更新请求比较版本号类似于乐观锁。","categories":[],"tags":[{"name":"后端存储实战","slug":"后端存储实战","permalink":"https://mink.yoonada.cn/tags/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"}]},{"title":"多线程","slug":"深入理解多线程","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-16T03:17:33.699Z","comments":true,"path":"2022/09/14/深入理解多线程/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"深入理解多线程1、线程基础概念​ 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。Java有6种状态（初始化，运行，阻塞，等待，等待超时，终止） 1、新建状态（New）：新创建了一个线程对象。 2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。6、等待超时（TIMED_WAITING）：具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，线程处于定时等待状态： Thread.sleepObject.wait超时Thread.join超时LockSupport.parkNanosLockSupport.parkUntil 2、Thread类解析1、控制线程执行优先级 1234567891011121314 /** * 线程可以拥有的最低优先级 */ public final static int MIN_PRIORITY = 1;/** * 线程默认的优先级 */ public final static int NORM_PRIORITY = 5; /** * 线程最大优先级 */ public final static int MAX_PRIORITY = 10; 通过getPriority() setPriority()来获取喝设置线程优先级， 1、java线程是通过映射到系统的原生线程上来实现的，所以线程的调度最终还是取决于操作系统，操作系统的优先级与java的优先级并不一一对应，如果操作系统的优先级级数大于java的优先级级数（10级）还好，但是如果小于得的话就不行了，这样会导致不同优先级的线程的优先级是一样的。2、优先级可能会被系统自动改变，比如windows系统中就存在一个优先级推进器，大致功能就是如果一个线程执行的次数过多的话，可能会越过优先级为他分配执行时间。 如果严格按照优先级，那么可能会出现某个线程一直不执行的情况","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"设计模式","slug":"设计模式","date":"2022-09-14T10:00:05.000Z","updated":"2022-09-16T03:17:33.711Z","comments":true,"path":"2022/09/14/设计模式/","link":"","permalink":"https://mink.yoonada.cn/2022/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计原理 SRP单一职责原则。 OCP开闭原则。 LSP里氏替换原则。 ISP接口隔离原则。 DIP依赖倒置原则。 DRY原则，KISS原则、YAGNI原则、LOD法则 。 设计模式1、创造型常用：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。 不常用：原型模式 2、结构模式常用：代理模式、桥接模式、装饰者模式、适配器模式。 不常用: 门面模式、组合模式、享元模式。 3、行为模式常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。 不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面对对象编程","slug":"面对对象编程","permalink":"https://mink.yoonada.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"}]},{"title":"docker-compose命令","slug":"docker-compose命令","date":"2022-08-04T06:53:08.000Z","updated":"2023-03-10T06:52:32.025Z","comments":true,"path":"2022/08/04/docker-compose命令/","link":"","permalink":"https://mink.yoonada.cn/2022/08/04/docker-compose%E5%91%BD%E4%BB%A4/","excerpt":"","text":"停掉服务，删除容器，不删除镜像1docker-compose down 重启&#x2F;开始&#x2F;停止服务1docker-compose restart/start/stop [服务名称] 运行某个服务1docker-compose run [服务名称] 查看服务中使用的镜像1docker-compose images [服务名称] 重新构建（强制删除之前的镜像重新打）并启动1docker-compose up -d --build --force-recreate 单机部署kafkaversion: ‘3’ services:kafka:image: wurstmeister&#x2F;kafka:2.13-2.7.0container_name: “kafka”ports: “9092:9092”environment: TZ&#x3D;Asia&#x2F;Shanghai KAFKA_ZOOKEEPER_CONNECT&#x3D;zookeeper:2181 KAFKA_AUTO_CREATE_TOPICS_ENABLE&#x3D;true KAFKA_ADVERTISED_HOST_NAME&#x3D;${IP} KAFKA_ADVERTISED_PORT&#x3D;9092 KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;:9092 KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;(要求改的ip):9092volumes: .&#x2F;kafka&#x2F;kafka&#x2F;:&#x2F;kafka &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sockrestart: always zookeeper:image: wurstmeister&#x2F;zookeeperports: “2181:2181”container_name: “zookeeper”restart: always","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker-compose","slug":"docker-compose","permalink":"https://mink.yoonada.cn/tags/docker-compose/"},{"name":"命令","slug":"命令","permalink":"https://mink.yoonada.cn/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"docker常用命令","slug":"docker常用命令","date":"2022-07-01T07:53:36.000Z","updated":"2022-10-28T03:17:20.644Z","comments":true,"path":"2022/07/01/docker常用命令/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"docker启动docker服务1systemctl start docker 关闭docker服务1systemctl stop docker 重启docker服务1systemctl restart docker 搜索镜像1docker search java 下载镜像1docker pull java:8 列出镜像1docker images 删除镜像 指定名称删除镜像1docker rmi java:8 指定名称删除镜像（强制）1docker rmi -f java:8 删除所有没有引用的镜像1docker rmi `docker images | grep none | awk &#x27;&#123;print $3&#125;&#x27;` 强制删除所有镜像1docker rmi -f $(docker images) 列出容器 列出运行中的容器1docker ps 列出所有容器1docker ps -a 停止容器1docker stop $ContainerName(or $ContainerId) 强制停止容器1docker kill $ContainerName 启动容器1docker start $ContainerName 进入容器 先查询出容器的pid1docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; $ContainerName 根据容器的pid进入容器1nsenter --target &quot;$pid&quot; --mount --uts --ipc --net --pid 查看容器的IP地址1docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; $ContainerName 将容器启动方式改为always12# 将容器启动方式改为alwaysdocker container update --restart=always $ContainerName 同步宿主机时间到容器1docker cp /etc/localtime $ContainerName:/etc/ 指定容器时区123docker run -p 80:80 --name nginx \\-e TZ=&quot;Asia/Shanghai&quot; \\-d nginx:1.17.0 查看容器资源占用状况 查看指定容器资源占用状况，比如cpu、内存、网络、io状态1docker stats $ContainerName 查看所有容器资源占用情况1docker stats -a 查看容器磁盘使用情况1docker system df 执行容器内部命令1docker exec -it $ContainerName /bin/bash 指定账号进入容器内部12# 使用root账号进入容器内部docker exec -it --user root $ContainerName /bin/bash 查看所有网络1docker network ls 创建外部网络1docker network create -d bridge my-bridge-network 指定容器网络123docker run -p 80:80 --name nginx \\--network my-bridge-network \\-d nginx:1.17.0 Docker容器清理 查看Docker占用的磁盘空间情况1docker system df 删除所有关闭的容器1docker ps -a | grep Exit | cut -d &#x27; &#x27; -f 1 | xargs docker rm 删除所有dangling镜像(没有Tag的镜像)1docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;) 删除所有dangling数据卷(即无用的 volume)1docker volume rm $(docker volume ls -qf dangling=true)","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"命令","slug":"命令","permalink":"https://mink.yoonada.cn/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"git配置ssh","slug":"git配置ssh","date":"2022-07-01T07:40:04.000Z","updated":"2022-08-04T08:40:07.000Z","comments":true,"path":"2022/07/01/git配置ssh/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/git%E9%85%8D%E7%BD%AEssh/","excerpt":"","text":"配置用户名1git config --global user.name &quot;yoonada&quot; 配置邮箱1git config --global user.email &quot;m15602498163@163.com&quot; 生成 ssh key1ssh-keygen -t rsa -b 4096 -C &quot;m15602498163@163.com&quot; 生成路径12window的生成路径：C:\\Users\\用户\\.sshLinux的生成路径：/etc/ssh","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://mink.yoonada.cn/tags/Git/"},{"name":"SSH","slug":"SSH","permalink":"https://mink.yoonada.cn/tags/SSH/"}]},{"title":"docker安装RabbitMQ","slug":"docker安装RabbitMQ","date":"2022-07-01T03:49:55.000Z","updated":"2022-10-28T03:17:47.624Z","comments":true,"path":"2022/07/01/docker安装RabbitMQ/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/docker%E5%AE%89%E8%A3%85RabbitMQ/","excerpt":"","text":"1docker run --name rabbitmq -p 5672:5672 -p 15672:15672 -d --restart=always rabbitmq:management","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://mink.yoonada.cn/tags/RabbitMQ/"}]},{"title":"docker安装redis","slug":"docker安装redis","date":"2022-07-01T03:49:20.000Z","updated":"2022-10-28T03:17:47.552Z","comments":true,"path":"2022/07/01/docker安装redis/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/docker%E5%AE%89%E8%A3%85redis/","excerpt":"","text":"1docker run --name redis -p 6380:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass &quot;DD123456aa&quot;","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"redis","slug":"redis","permalink":"https://mink.yoonada.cn/tags/redis/"}]},{"title":"docker安装nacos","slug":"docker安装nacos","date":"2022-07-01T03:49:11.000Z","updated":"2022-10-28T03:17:47.577Z","comments":true,"path":"2022/07/01/docker安装nacos/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/docker%E5%AE%89%E8%A3%85nacos/","excerpt":"","text":"拉取docker镜像1docker pull nacos/nacos-server:1.4.2 创建临时容器（用来拷贝配置、日志使用）1docker run -p 8848:8848 --name nacostest -d nacos/nacos-server:1.4.2 创建文件夹1mkdir -p /mydata/nacos/conf 1mkdir -p /mydata/nacos/logs 配置文件复制1docker cp nacostest:/home/nacos/logs/ /mydata/nacos/ 1docker cp nacostest:/home/nacos/conf/ /mydata/nacos/ 删除临时容器1docker stop nacostest 1docker rm nacostest 创建并启动容器123456789101112131415docker run -d \\-e MODE=standalone \\-e SPRING_DATASOURCE_PLATFORM=mysql \\-e MYSQL_SERVICE_HOST=43.142.62.156 \\-e MYSQL_SERVICE_PORT=3307 \\-e MYSQL_SERVICE_USER=root \\-e MYSQL_SERVICE_PASSWORD=DD123456aa \\-e MYSQL_SERVICE_DB_NAME=nacos_config \\-e TIME_ZONE=&#x27;Asia/Shanghai&#x27; \\-v /mydata/nacos/logs:/home/nacos/logs \\-v /mydata/nacos/conf:/home/nacos/conf \\-p 8848:8848 \\--name nacos \\--restart=always \\nacos/nacos-server:1.4.2","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"nacos","slug":"nacos","permalink":"https://mink.yoonada.cn/tags/nacos/"}]},{"title":"docker安装MySQL","slug":"docker安装MySQL","date":"2022-07-01T03:49:00.000Z","updated":"2022-10-28T03:17:47.417Z","comments":true,"path":"2022/07/01/docker安装MySQL/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/docker%E5%AE%89%E8%A3%85MySQL/","excerpt":"","text":"拉取5.7的镜像1docker pull mysql:5.7 启动容器1docker run --name mysql -p 3307:3306 --restart=always -e MYSQL_ROOT_PASSWORD=DD123456aa -d mysql:5.7 进入容器1docker exec -it mysql bash 登录1mysql -u root -p 开启远程连接1ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;DD123456aa&#x27;; 刷新1flush privileges;","categories":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://mink.yoonada.cn/tags/MySQL/"}]},{"title":"centos常用命令","slug":"centos常用命令","date":"2022-07-01T03:39:11.000Z","updated":"2022-10-28T03:16:50.905Z","comments":true,"path":"2022/07/01/centos常用命令/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"开启防火墙1systemctl start firewalld 关闭防火墙1systemctl stop firewalld 查看防火墙状态1systemctl status firewalld 开放某个端口1firewall-cmd --zone=public --add-port=80/tcp --permanent 重新加载配置1firewall-cmd --reload 查看已经开放的端口1firewall-cmd --zone=public --list-ports 查找（在**中填写你要的查找的路径）1find / -name **","categories":[{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"命令","slug":"centos装机必备/命令","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"命令","slug":"命令","permalink":"https://mink.yoonada.cn/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"centos安装nginx","slug":"centos安装nginx","date":"2022-07-01T03:23:10.000Z","updated":"2022-10-28T03:16:25.552Z","comments":true,"path":"2022/07/01/centos安装nginx/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/centos%E5%AE%89%E8%A3%85nginx/","excerpt":"","text":"安装依赖1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 下载稳定版本1wget http://nginx.org/download/nginx-1.16.1.tar.gz 解压1tar -zxvf nginx-1.16.1.tar.gz 进入目录1cd nginx-1.16.1 配置编译1./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 安装1make &amp;&amp; make install 被安装的目录1/usr/local/nginx/","categories":[{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"环境","slug":"centos装机必备/环境","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"nginx","slug":"nginx","permalink":"https://mink.yoonada.cn/tags/nginx/"}]},{"title":"centos安装docker-compose","slug":"centos安装docker-compose","date":"2022-07-01T02:57:31.000Z","updated":"2022-10-28T03:14:28.128Z","comments":true,"path":"2022/07/01/centos安装docker-compose/","link":"","permalink":"https://mink.yoonada.cn/2022/07/01/centos%E5%AE%89%E8%A3%85docker-compose/","excerpt":"","text":"1curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 1chmod +x /usr/local/bin/docker-compose","categories":[{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"docker","slug":"centos装机必备/docker","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/docker/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://mink.yoonada.cn/tags/docker-compose/"}]}],"categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://mink.yoonada.cn/categories/SpringBoot/"},{"name":"集成框架","slug":"SpringBoot/集成框架","permalink":"https://mink.yoonada.cn/categories/SpringBoot/%E9%9B%86%E6%88%90%E6%A1%86%E6%9E%B6/"},{"name":"日常问题","slug":"日常问题","permalink":"https://mink.yoonada.cn/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"centos装机必备","slug":"centos装机必备","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/"},{"name":"环境","slug":"centos装机必备/环境","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/%E7%8E%AF%E5%A2%83/"},{"name":"docker","slug":"centos装机必备/docker","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/docker/"},{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/categories/docker/"},{"name":"部署","slug":"docker/部署","permalink":"https://mink.yoonada.cn/categories/docker/%E9%83%A8%E7%BD%B2/"},{"name":"spring事务","slug":"spring事务","permalink":"https://mink.yoonada.cn/categories/spring%E4%BA%8B%E5%8A%A1/"},{"name":"命令","slug":"centos装机必备/命令","permalink":"https://mink.yoonada.cn/categories/centos%E8%A3%85%E6%9C%BA%E5%BF%85%E5%A4%87/%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://mink.yoonada.cn/tags/SpringBoot/"},{"name":"定时任务","slug":"定时任务","permalink":"https://mink.yoonada.cn/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"环境部署","slug":"环境部署","permalink":"https://mink.yoonada.cn/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"nginx","slug":"nginx","permalink":"https://mink.yoonada.cn/tags/nginx/"},{"name":"centos","slug":"centos","permalink":"https://mink.yoonada.cn/tags/centos/"},{"name":"maven","slug":"maven","permalink":"https://mink.yoonada.cn/tags/maven/"},{"name":"docker","slug":"docker","permalink":"https://mink.yoonada.cn/tags/docker/"},{"name":"JVM","slug":"JVM","permalink":"https://mink.yoonada.cn/tags/JVM/"},{"name":"RPC","slug":"RPC","permalink":"https://mink.yoonada.cn/tags/RPC/"},{"name":"sql","slug":"sql","permalink":"https://mink.yoonada.cn/tags/sql/"},{"name":"spring事务","slug":"spring事务","permalink":"https://mink.yoonada.cn/tags/spring%E4%BA%8B%E5%8A%A1/"},{"name":"微服务","slug":"微服务","permalink":"https://mink.yoonada.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"后端存储实战","slug":"后端存储实战","permalink":"https://mink.yoonada.cn/tags/%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E6%88%98/"},{"name":"Java基础","slug":"Java基础","permalink":"https://mink.yoonada.cn/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"面对对象编程","slug":"面对对象编程","permalink":"https://mink.yoonada.cn/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"name":"docker-compose","slug":"docker-compose","permalink":"https://mink.yoonada.cn/tags/docker-compose/"},{"name":"命令","slug":"命令","permalink":"https://mink.yoonada.cn/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Git","slug":"Git","permalink":"https://mink.yoonada.cn/tags/Git/"},{"name":"SSH","slug":"SSH","permalink":"https://mink.yoonada.cn/tags/SSH/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://mink.yoonada.cn/tags/RabbitMQ/"},{"name":"redis","slug":"redis","permalink":"https://mink.yoonada.cn/tags/redis/"},{"name":"nacos","slug":"nacos","permalink":"https://mink.yoonada.cn/tags/nacos/"},{"name":"MySQL","slug":"MySQL","permalink":"https://mink.yoonada.cn/tags/MySQL/"}]}